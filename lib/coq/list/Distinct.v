(********************************************************************)
(*                                                                  *)
(*  The Why3 Verification Platform   /   The Why3 Development Team  *)
(*  Copyright 2010-2025 --  Inria - CNRS - Paris-Saclay University  *)
(*                                                                  *)
(*  This software is distributed under the terms of the GNU Lesser  *)
(*  General Public License version 2.1, with the special exception  *)
(*  on linking described in file LICENSE.                           *)
(********************************************************************)

(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require list.List.
Require list.Length.
Require list.Mem.
Require list.Append.

(* Why3 assumption *)
Fixpoint distinct {a:Type} {a_WT:WhyType a}
  (l:Init.Datatypes.list a) {struct l}: Prop :=
  match l with
  | Init.Datatypes.nil|(Init.Datatypes.cons _ Init.Datatypes.nil) => True
  | Init.Datatypes.cons x xs => ~ list.Mem.mem x xs /\ distinct xs
  end.

(* Why3 goal *)
Lemma distinct_append {a:Type} {a_WT:WhyType a} :
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a),
  distinct l1 -> distinct l2 ->
  (forall (x:a), list.Mem.mem x l1 -> ~ list.Mem.mem x l2) ->
  distinct (Init.Datatypes.app l1 l2).
Proof.
intros l1 l2 h1 h2 h3.
induction l1 as [|l1h l1t IHl1].
exact h2.
simpl.
simpl in h1.
destruct l1t.
- destruct l2.
  easy.
  split.
  apply h3.
  constructor. easy.
  easy.
- destruct h1.
  split.
  contradict H.
  apply Append.mem_append in H.
  destruct H as [H1|H1].
  exact H1.
  elim h3 with (2 := H1).
  now left.
  apply IHl1 with (1 := H0).
  intros x Hx.
  apply h3.
  now right.
Qed.

